
LoadGenomeStartIDs := proc()
    global GSID, GSPOR, NS: 
    t := traperror(ReadProgram(datdir.'/GenomeStarts.drw'));
    if t=lasterror then 
        ReadProgram(omaDBpath.'Summaries.drw');
	GS := GenomeSummaries;
	NS := length(genomes);
        GSID  := CreateArray(1..NS);
	GSPOR := transpose( sort([seq([genomes[g],g],g=1..NS)]) );
        
        for g to length(genomes) do
	    GSID[g] := [If(g=1, 1, GSID[g-1,1]+GSID[g-1,3]), 
	                genomes[g], GS[genomes[g],TotEntries]];
        od:
	GSID := transpose(sort(GSID));
	OpenWriting(datdir.'/GenomeStarts.drw');
	printf('# created %s\n', date());
	printf('NS := %d\n: GSID := %A:\nGSPOR := %A:\n', NS,GSID, GSPOR);
	OpenWriting(previous);
    fi;
end:

GenomeNrFromENr := proc(eNr:posint)
    if not assigned(GSID) then LoadGenomeStartIDs() fi:
    g := SearchOrderedArray(eNr, GSID[1]):
    assert(g > 0 and g <= NS):
    return( g ):
end:

GenomeNrFromCode := proc(g:string)
    if not assigned(GSID) then LoadGenomeStartIDs() fi:
    if length(g)<>5 then error('invalid genome code: '.g);
    else
        k := SearchOrderedArray(g, GSPOR[1]);
        if k<=0 or k>NS or GSPOR[1,k]<>g then 
            error('unknown genome code: '.g); fi:

        return(GSPOR[2,k]);
    fi:
end:

GenomeRange := proc(g:string)
    i := GenomeNrFromCode(g);
    return( GSID[1,i]..GSID[3,i]-1 );
end:


GenomeCodeFromENr := proc(eNr:posint)
    if not assigned(GSID) then LoadGenomeStartIDs() fi:
    return( GSID[2, GenomeNrFromENr(eNr)] ):
end:


ENrFromLabel := proc(l:string)
    if not assigned(GSID) then LoadGenomeStartIDs() fi:
    if length(l)<6 then error('invalid EntryLabel: '.l);
    else 
        org := l[1..5];
        k := SearchOrderedArray(org, GSPOR[1]):
        if k<=0 or k>NS or GSPOR[1,k]<>org then 
            error('unknown Species: ',org) fi:
       
        nr := parse(l[6..-1]):
        if not type(nr, posint) or nr >= GSID[3,GSPOR[2,k]] then 
            error('not a valid entry nr: '.l); fi:
	
        return( GSID[1,GSPOR[2,k]] + nr - 1 );
    fi:
end:
       
ENr2Label := proc(eNr:posint)
    g := GenomeNrFromENr(eNr):
    return( eNr - GSID[1,g] + 1 );
end:


#####################################################
# Encode ENTRYNR in Seqence Tag to quickly query for
# the entry belonging to ENTRYNR.
Nr2SEQ := proc(p:posint)
    base := 16:
    N := floor(log(p)/log(base)+3):
    s := CreateString(N);
    rem := p;
    s[1] := 'X':
    for j from 2 to N-1 do 
        x := floor(rem/base);
        s[j] := IntToA(rem-base*x+1);
        rem := x;
    od:
    s[N] := 'X':
    return(s):
end:

DbEntryNrFromENr := proc(oE:posint)
    s := Nr2SEQ(oE):
    pat := SearchSeqDb(s):
    if pat[1,2] = pat[1,1] then
        GetEntryNumber(DB[Pat,pat[1,1]]);
    elif pat[1,2]<pat[1,1] then
        NULL;
    else print(Entry(pat)); error('more than one Entry with same ID.') 
    fi:
end:

###############
# Parses a potentially long LIST of more than 70000 chars.
ParseLongList := proc(s:string)
    if length(s) <= 70000 then return(parse(s));
    else
            parts := SearchDelim(',', s[2..-2]);
            return( [seq( parse(z), z=parts)] );
    fi;
end:


KnownSpecies := proc()
   if not assigned(GSID) then LoadGenomeStartIDs() fi:
   return( sort(GSID[2]) );
end:
