#
# this script receives resDBfn, relsinfn, seqmapfn, orgMap, lock, PID
#
WriteLock(lock,'initializing computation');
#ReadProgram('/local/BenchmarkService/lib/darwinit');

GenerateProteinMapping := proc( seqMapFn:string, selOrg:list )
    global MappingComb;
    MappingComb := 0;
    ReadProgram(seqMapFn):
    if MappingComb=0 then error('could not read sequence mapping file') fi:

    mapping := []:
    for pg to length(selOrg) do if selOrg[pg]>0 then
        mapping := append(mapping, op(MappingComb[pg,selOrg[pg]]));
    fi od:
    mapping := sort(mapping);
    pset := {seq(z[2],z=mapping)};
    plist:= [op(pset)];
    mapping := transpose( [seq([z[1],z[2],SearchOrderedArray(z[2],plist)], 
                           z=mapping)]);
    return(mapping, pset);
end:

UpdateRemainingTime := proc()
    remTime := time()/relDone * (pKey['NOrthSub']-relDone);
    unit := 'sec';
    if remTime>120 then remTime := remTime/60; unit:='min'; fi:
    WriteLock(lock, sprintf(
        '%d/%d (%.1f%%) relations processed. Estimated remaining time:%.0f%s\n',
	 relDone, pKey['NOrthSub'], 100*relDone/pKey['NOrthSub'], remTime, unit));
end:

# callback function pairwise data
PairRelations := proc(rel:list)
    global VPs, relDone, t0, relMapped;
    for z in rel do
        i1 := SearchOrderedArray(z[1], mapping[1]);
        if i1<=0 or i1>NM or mapping[1,i1]<>z[1] then lprint('missing',z); next fi;
        i2 := SearchOrderedArray(z[2], mapping[1]);
        if i2<=0 or i2>NM or mapping[1,i2]<>z[2] then lprint('missing',z); next fi;
        p1 := mapping[3,i1]; p2 := mapping[3,i2];

        VPs[p1] := append(VPs[p1], p2); 
        VPs[p2] := append(VPs[p2], p1);
	relMapped := relMapped+1;
    od:
    relDone := relDone + length(rel);
    if not assigned(t0) or time()-t0>5 then 
        UpdateRemainingTime(); t0 := time(); 
    fi:
end:

# callback function group data
GroupRelations := proc(gps:list)
    global VPs;
    grp := [];
    for z in gps do
       i := SearchOrderedArray(z, mapping[1]);
       if i<=0 or i>NM or mapping[1,i]<>z then next fi:
       iSetNr := mapping[3,i]; 
       g := GenomeNrFromENr(iSet[iSetNr]);
       grp := append(grp, [g,iSetNr]);
    od:
    
    for i to length(grp) do for j to length(grp) do if grp[i,1]<>grp[j,1] then
       VPs[grp[i,2]] := append(VPs[grp[i,2]], grp[j,2]);
       VPs[grp[j,2]] := append(VPs[grp[j,2]], grp[i,2]);
    fi od od:
end:


WriteDB := proc(fn:string, VPs, mapping)
    verb := Set(printgc=false);
    OpenWriting(fn);
    for i to length(VPs) do
        oE := iSet[i]; 
        vps := [op({seq(iSet[z],z=VPs[i])})];
        printf('<E><OE>%d</OE><VP>%A</VP><SEQ>%s</SEQ></E>\n',
           oE, vps, Nr2SEQ(oE) );
    od:
    OpenWriting(previous);
    
    OpenWriting( fn[1..-3].'iset' );
    printf('ISET := %A:\n', iSet);
    OpenWriting( previous ); 
    Set(printgc=verb);
end:

# to break at error
to 1 do
    pKey := GetPKeyData(PID);
    t := GenerateProteinMapping(seqmapfn, orgMap):
    mapping := t[1]; iSet := t[2]:
    NM := length(iSet):
    VPs := CreateArray(1..NM,[]);
    relDone := relMapped := 0;
    ReadProgram(relsinfn);
    WriteLock(lock, 'Storing final project data');
    WriteDB(resDBfn, VPs, mapping);
    ReadDb(resDBfn);

    pKey['NSeqMap'] := NM; pKey['NOrthMap'] := relMapped;
    orgs := {seq(GenomeCodeFromENr(z),z=iSet)}:
    pKey['OrgsCovered'] := orgs:
    UpdatePKeyDataPermanent(pKey);

    CallSystem('rm -f '.lock);
od:
done
