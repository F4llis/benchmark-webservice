##
#  Script to run the species tree discordance test  
#
#  in: resFn, problem, projs, lock
Set(printgc=false):

OpenWriting(lock); lprint(getpid()); OpenWriting(previous);
CreateDayMatrices();

prj := [seq(GetPKeyData(z),z=projs)]:
LoadGenomeStartIDs(); # initalizes GSID

ReadProgram(problem); # this loads the species tree and the bins containg species
nrBins := length(catBins);
catBinsNr := [seq({seq(GenomeNrFromCode(g),g=catBins[i])}, i=1..nrBins)];
# lookup table for a genome to which bin it belongs (if any)
orgNr2Bin := table(0);
for i to nrBins do for z in catBinsNr[i] do orgNr2Bin[z] := i; od od:

# load the project databases
nP := length(prj); dbs := CreateArray(1..nP):
for i to nP do dbs[i] := DB := ReadDb( prj[i,'fnBase'].'.db' ); od:

FindCases := proc(iSet, prjNrs:list)
    global DB:
    cases := []; nP := length(prjNrs);
    for rootGenome in catBins[1] do 
        ran := GenomeRange(rootGenome):
        for oE from ran[1] to ran[2] do
            if not member(oE, iSet) then next fi:
            
            assert( orgNr2Bin[GenomeNrFromENr(oE)]=1 );
            treeProt := CreateArray(1..nP): 
            # logical array if lineage is present in all projects
            miss := CreateArray(1..nrBins, 0);
            goOn := true;
            for i2pNr to nP do
	        pNr := prjNrs[i2pNr];
                # get entry nr of project DB of protein having omaEntryNr oE
                DB := dbs[pNr];
                eNr := If( prj[pNr,'directMap'], oE, DbEntryNrFromENr(oE) );
                
                vps := ParseLongList(SearchTag('VP', Entry(eNr)));
                vpCat := CreateArray(1..nrBins,[]):
                for vp in vps do
                    if not member(vp,iSet) then next fi;
                    
                    bin := orgNr2Bin[ GenomeNrFromENr(vp) ]:
                    if bin>1 then vpCat[bin] := append(vpCat[bin], vp) fi:
                od:
    	        for i from 2 to nrBins do 
    	            if length(vpCat[i])>0 then
    	                vpCat[i] := vpCat[i, Rand(1..length(vpCat[i]))];
    	            else 
    	                miss[i] := 1;
    	                vpCat[i] := 0;
    	            fi:
                od:
    	        vpCat[1] := oE;
                treeProt[i2pNr] := vpCat;
    
                # check if we're still below the missing lineage limit, 
                # otherwise break the loop and go on with the next candidate 
                # protein.
                if sum(miss) > missThreshold then 
                    goOn := false; break;
                fi:
            od:
            
            # only keep the cases that have not too much missing lineages
            if goOn then 
	        for i to nrBins do if miss[i]>0 then for j to nP do 
                    treeProt[j,i] := 0 od fi od:
                cases := append(cases, treeProt):
            fi: 
        od:
    od:
    
    if length(cases) > MAX_NR_TREES then
        cases := Shuffle(cases)[1..MAX_NR_TREES]:
    fi:
    lprint('nr of cases:',length(cases));
    return(cases):
end:

ComputeCongruenceStat := proc(prjNrs:list(posint), cases:list, totNrTrees:posint)
    global DB, Ndone:
    RFstat := [seq( Stat(prj[i,'Title']), i=prjNrs)];
    DB := SeqDB := ReadDb(omaDBpath.'ServerSeqs.db'):
    cErr := Counter('# errors in PhylogeneticTree');
    if not type(Ndone, integer) then Ndone:=0 fi:

    for cas in cases do
        for pNr to length(prjNrs) do
            seqs := labs := [];
            for i to nrBins do if cas[pNr,i]>0 then 
                seqs := append(seqs, Sequence(Entry(cas[pNr,i])));
                labs := append(labs, i);
            fi od:
            genetree := traperror(PhylogeneticTree(seqs, labs, DISTANCE));
            if genetree=lasterror then cErr+1; next fi;
            
            pruned_st := PruneTree(speciestree, labs);
            RFstat[pNr] + RobinsonFoulds([genetree, pruned_st])[1,2];
        od;
        
        Ndone := Ndone+1;
	t := Ndone/totNrTrees;
        msg := sprintf( 'Finished %d / %d (%.1f%%) trees in %.1f min. Estimated remaining time: %.1fmin\n', 
            Ndone, totNrTrees, 100*t, (time()-t0)/60, (1-t)/t*(time()-t0)/60 );
        WriteLock(lock,msg);
    od:
    print('# result for '.ConcatStrings([seq(prj[i,'Title'],i=prjNrs)],' - '), op(RFstat), cErr);
    return(RFstat);
end:

StoreResult := proc(fn:string, RFstat, PIDs)
    OpenWriting(fn):
    printf('RFstat := %A:\n', RFstat):
    printf('PIDs := %A:\n', PIDs );
    OpenWriting(previous):
end:

if meth='INTERSECT' then
    iSet  := GetProjISets(prj);
    prjNrs:= [seq(i,i=1..nP)];
    cases := FindCases(iSet, prjNrs);
    t0 := time();
    RFstat := ComputeCongruenceStat(prjNrs, cases, length(cases)):
    StoreResult(resFn, RFstat, [seq(prj[i,'PID'], i=prjNrs)]);
elif meth='PAIRWISE' then
    cases := CreateArray(1..nP-1,[]):
    RFstats := CreateArray(1..nP-1):
    prjNrs := [seq([i,nP],i=1..nP-1)];
    resFnParts := CreateArray(1..nP-1):
    resFnBase := resFn[1..(SearchAllString('.',resFn)[-2])];
    for i to nP-1 do 
        curPrjPIDs := [seq(prj[j,'PID'],j=prjNrs[i])]:
        resFnParts[i] := sprintf('%s%a.drw', resFnBase, hash([curPrjPIDs,'INTERSECT']) );
	if FileExists(resFnParts[i]) then next fi:
        iSet := GetProjISets( [seq(prj[j],j=prjNrs[i])] ):
        cases[i] := FindCases( iSet, prjNrs[i] );
    od:
    t0 := time();
    totNrTrees := sum(length(z),z=cases):
    for i to nP-1 do
        if FileExists(resFnParts[i]) then
	   RFstat := 0; ReadProgram(resFnParts[i]): assert(length(RFstat)=2); RFstats[i] := RFstat;
	else
           RFstats[i] := ComputeCongruenceStat(prjNrs[i], cases[i], totNrTrees):
	   StoreResult(resFnParts[i], RFstats[i], [seq(prj[j,'PID'],j=prjNrs[i])]);
	fi:
    od:
    StoreResult(resFn, RFstats, [seq([prj[i,'PID'],prj[nP,'PID']],i=1..nP-1)]);
else error('unknown strategy method:'.meth); 
fi:

CallSystem('rm -f '.lock);
done;

