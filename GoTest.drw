# 
# A script to measures the similarity between the putative orthologs 
# based on the code of the benchmark paper.
#
#                               Adrian Altenhoff, Sept 2006
#                  rewritten    Adrian Altenhoff, July 13, 2007
#   rewritten for BenchService  Adrian Altenhoff, Dec 4, 2009  
#
#  in: resFn, filter, projs, lock, measure

Set(printgc=false); Set(gc=5e6):
OpenWriting(lock); lprint(getpid()); OpenWriting(previous);

prj := [seq(GetPKeyData(z),z=projs)]:
iSet := GetProjISets(prj);
LoadGenomeStartIDs(); # initalizes GSID

# load the project databases
nP := length(prj); dbs := CreateArray(1..nP):
for i to nP do dbs[i] := DB := ReadDb( prj[i,'fnBase'].'.db' ); od:

nGo := 1e5;
GOparents := CreateArray(1..nGo):
for i to nGo do GOparents[i] := GOsuperclassR(i) od:

# extract important all GO annotations from ServerIndexed.db
DB := GODB := ReadDb(omaDBpath.'ServerIndexed.db'):
directMap := evalb(iSet=intersect()):
nProt := If(directMap,GODB[TotEntries],length(iSet)):
GOs := CreateArray(1..nProt,[]):
DB := GODB;
for i to nProt do 
    eNr := If(directMap, i, iSet[i]);
    gos := SearchTag('GO', Entry(eNr));
    if gos='' then next fi;
    gos := SearchDelim('; ',gos);
    
    gos := [seq(SearchDelim('@',z), z=gos)];
    for z in gos do if length( intersect({z[2,2..-2]}, filter) )>0 then
        GOs[i] := append(GOs[i], parse(z[1,4..-1]) );
    fi od:
od:

# compute GO term frequencies of proteins in iSet;
freqs := CreateArray(1..nGo): cnts := 0;
for p in GOs do for go in p do
    cnts := cnts+1;
    freqs[go] := freqs[go]+1;
    for parent in GOparents[go] do freqs[parent] := freqs[parent]+1; od:
od od:
freqs := freqs/cnts;

ComputeSimilarity := proc(data:list; 'method'=(method:string))
    if method='avg Sim' then
        return( avg(seq(z[2],z=data)) );
    elif method='max Sim' then 
        return( max(seq(z[2],z=data)) );
    elif method='avg Info' then
        return( avg(seq(z[3], z=data)) );
    elif method='max Info' then
        return( max(seq(z[3], z=data)) );
    elif method='avg Schlicker' then
        max1 := CreateArray(1..max(seq(z[4],z=data)),1..2,-DBL_MAX);
        max2 := CreateArray(1..max(seq(z[5],z=data)),1..2,-DBL_MAX);
	for i to length(data) do
	     z := data[i];
	     if z[2] > max1[z[4],1] then max1[z[4]] := [z[2],i]; fi; 
	     if z[2] > max2[z[5],1] then max2[z[5]] := [z[2],i]; fi; 
	od:
	s := c := 0;
	for i in [op(max1),op(max2)] do
	    if i[1]>-DBL_MAX then s := s+i[1]; c:=c+1; fi:
	od:
	return( s/c );
    else error('similarity not implemented') fi:
end:

# measure similarities between putative orthologs
Sims := [seq(Stat(z['Title']), z=prj)];
iList := [op(iSet)]:
onts := [3674, 5575, 8150]:
for pNr to nP do 
    DB := dbs[pNr];
    for i to nProt do if length(GOs[i]) > 0 then
        oE := If(directMap, i, iSet[i]);
        eNr := If( prj[pNr,'directMap'], oE, DbEntryNrFromENr(oE) );
    
        vps := ParseLongList(SearchTag('VP', Entry(eNr)));
        for vp in vps do 
            if vp<oE then next fi: # uni-directional
            if not member(vp, iSet) then next fi; # 
            
            k := SearchOrderedArray(vp, iList):
            assert(k>0 and k<nProt and iList[k]=vp);
            if length(GOs[k]) = 0 then next fi:
           
            pairs := [];
            for ig1 to length(GOs[i]) do for ig2 to length(GOs[k]) do
                go1 := GOs[i,ig1]; go2 := GOs[k,ig2];
                ic := intersect( {go1, op(GOparents[go1])},
                                 {go2, op(GOparents[go2])} );
                if length(ic)=0 then next fi: # skip if not same ontology

                ont := sum(SearchArray(z, onts),z=ic); # get ontology
                if ont<1 or ont>3 then next fi:

                 #                     2*ln(prob(interClass[i]))
                 # similarity   sim = ---------------------------
                 #                    ln(prob(go1))+ln(prob(go2))
                simRun := infoRun := -DBL_MAX;
                for int in ic do
                    info := -2*ln(freqs[int]);
                    sim  := If(info=0, 0, -info/(ln(freqs[go1])+ln(freqs[go2])));
                    if info > infoRun then infoRun := info; infoInt := int fi;
                    if sim  > simRun  then simRun := sim; simInt := int fi;
                od:
                pairs := append(pairs, [ont, simRun, infoRun, ig1, ig2] );
            od od:
            Sims[pNr] + ComputeSimilarity(pairs, 'method'=measure);
        od:
    fi od:
od:
            
OpenWriting(resFn);
printf('Sims := %A:\nPIDs := %A:\n', Sims, [seq(z['PID'],z=prj)]);
OpenWriting(previous);
done;

