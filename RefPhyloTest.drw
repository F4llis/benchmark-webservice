##
#  Script to run the reference phylogeny tests. 
#
#  in: resFn, problems, projs, lock
Set(printgc=false):

OpenWriting(lock); lprint(getpid()); OpenWriting(previous);

IDIndex := ReadDb(omaDBpath.'IDIndex.db');

prj := [seq(GetPKeyData(z),z=projs)]:
iSet := GetProjISets(prj);
LoadGenomeStartIDs(); # initalizes GSID

# load the project databases
nP := length(prj); dbs := CreateArray(1..nP):
for i to nP do dbs[i] := DB := ReadDb( prj[i,'fnBase'].'.db' ); od:

ReadProgram(datdir.'ReconciledTrees.drw'); #Assigns ReconciledTrees (a table)
nrProb := length(problems);

MatchID := proc(id:string)
    oE := SearchIndex(id,IDIndex);
    if oE<>NULL then return(oE) fi:
    
    k := SearchString('_',id);
    oE := SearchIndex(id[1..k], IDIndex); 
    if k=6 and oE<>NULL then return(oE); # we have an uniprot-id -> accession
    elif oE<>NULL and length(id[k+2..-1])=5 then
         # double-check if species is the same
         if GenomeCodeFromENr(oE)=id[k+2..-1] then return(oE) fi:
    else lprint('can''t map id:',id);
    fi:
    return(NULL);
end:
ExtractPairwiseRel := proc(t:Tree)
    global __PWR; __PWR := table();
    prots := ExtractPairRelR(t):
    return( [prots, __PWR] );
end:
ExtractPairRelR := proc(t:Tree)
    global __PWR;
    if type(t, Leaf) then 
        oE := MatchID(t[Label],IDIndex):
    if oE=369230 then lprint(t[Label],'-->',oE) fi;
    return( If(oE=NULL,NULL,{oE}) );
    else
        
        tL := ExtractPairRelR(t[Left]);
    tR := ExtractPairRelR(t[Right]);
    if tL=NULL then return(tR);
    elif tR=NULL then return(tL);
    else 
        if intersect(tL,tR)<>{} then 
            lprint('intersect not empty:'.string(intersect(tL,tR)).' '.t[4]); 
        tL := minus(tL, tR);
        fi;
        for p1 in tL do for p2 in tR do 
            assert(__PWR[{p1,p2}]=unassigned);
            __PWR[{p1,p2}] := t[4];
        od od:
        return( union(tL,tR) );
    fi:
    fi:
end:

# false positive and true positive rates.
#  - set to 0 to indicate no data
#  - set to list [fpr, var(fpr)] once data is stored
fpr  := CreateArray(1..nrProb,1..nP,0);
tpr  := CreateArray(1..nrProb,1..nP,0);
avgFPR := CreateArray(1..nP,
DUPL := {':D=Y','D=Y','D','DUPLICATION'}; SPEC := {':D=N','D=N','S','SPECIATION'};
for prNr to nrProb do 
    tree := ReconciledTrees[problems[prNr],'Tree'];
    tmp := ExtractPairwiseRel(tree);
    rels := tmp[2];
    prts := intersect(tmp[1],iSet); 
    nProt := length(prts);
    if nProt>5 then 
    
        dups := table({}); specs := table({});
        for p1 in prts do for p2 in prts do 
            ev := rels[{p1,p2}];
        if member(ev,DUPL) then dups[p1] := append(dups[p1], p2);
        elif member(ev,SPEC) then specs[p1] := append(specs[p1],p2); fi:
        od od:
        
        # we iterate over all the projects
        for pNr to nP do 
            DB := dbs[pNr];
            # iteration over the proteins in iSet and current reconciled tree
            fp := tp := fn := tn := 1; #uniform prior probability
            for oE1 in prts do
                eNr1 := If(prj[pNr,'directMap'], oE1, DbEntryNrFromENr(oE1));
                vps := ParseLongList(SearchTag('VP',Entry(eNr1)));
                vps := {op(vps)} intersect prts;
                    
                tp := tp + length( intersect(vps, specs[oE1]) )/2;
                tn := tn + length( minus(dups[oE1], vps) )/2;
                fp := fp + length( intersect(vps, dups[oE1]) )/2;
                fn := fn + length( minus(specs[oE1], vps) )/2;
            od:
            assert( tp+tn+fp+fn-4 = nProt*(nProt-1)/2 );
            # compute the fpr and tpr and their variances
            p := fp/(fp+tn); 
            fpr[prNr,pNr] := [p, p*(1-p)/(fp+tn)];
            p := tp/(tp+fn); 
            tpr[prNr,pNr] := [p, p*(1-p)/(tp+fn)];
        od:
    else 
        printf('too few (%d) proteins in %a\n',nProt,problems[prNr]);
    fi:
od:

OpenWriting(resFn);

OpenWriting(previous);

CallSystem('rm -f '.lock);
done;

