# 
# This file precomputes the mapping of the reference phylogenetic trees to 
# the EntryNumbers and stores those files in data/ReconciledTrees.drw
#
ReadProgram('lib/darwinit');
DUPL := {':D=T',':D=Y','D=Y','D','DUPLICATION',':Ev=duplication',':Ev=DUPLICATION'};
SPEC := {':D=F',':D=N','D=N','S','SPECIATION',':Ev=speciation',':Ev=SPECIATION'};
SPEC_MATCH := SPEC minus {'S','SPECIATION'}:
DUPL_MATCH := DUPL minus {'D','DUPLICATION'}:
overwrite := true:

SetDatasetVariables := proc(;(ref='OMA'):string)
    global outfile, outfile_semiauto, IDIndex, DB;
    outfile := datdir.'ReconciledTrees_'.ref.'.drw':
    outfile_semiauto := datdir.'ReconciledTreesSemiAuto_'.ref.'.drw':
    ddir := eval(symbol(lowercase(ref).'DBpath'));
    IDIndex := ReadDb(ddir.'IDIndex.db');
end:

MatchID := proc(id:string)
    oE := SearchIndex(id,IDIndex);
    if oE<>NULL then return(oE) fi:

    k := SearchString('_',id);
    oE := SearchIndex(id[1..k], IDIndex);
    if k=6 and oE<>NULL then return(oE); # we have an uniprot-id -> accession
    elif oE<>NULL and length(id[k+2..-1])=5 then
         # double-check if species is the same
         if GenomeCodeFromENr(oE)=id[k+2..-1] then return(oE) fi:
#   else lprint('can''t map id:',id);
    fi:
    return(NULL);
end:

ExtractPairRelR := proc(t:Tree ; (mappings=NULL):table)
    global __PWR;
    if type(t, Leaf) and mappings=NULL then
        oE := MatchID(t[Label],IDIndex):
	if oE=NULL then  lprint('can''t map protein '''.t[Label].'''') fi:
        return( If(oE=NULL,NULL,{oE}) );
    elif type(t,Leaf) then
        if length( mappings[t[Label]] ) = 0 then 
	    lprint(t[Label].' not found in mappings -> silently skipping');
	    oE := NULL;
	else 
            for z in mappings[t[Label]] while MatchID(z,IDIndex)=NULL do od:
            oE := MatchID(z,IDIndex);
	    if oE=NULL then  lprint('can''t map protein '''.t[Label].'''') fi:
	fi:
	return( If(oE=NULL,NULL,{oE}) ):
    else
        tL := ExtractPairRelR(t[Left], mappings );
        tR := ExtractPairRelR(t[Right],mappings ); 
        if tL=NULL then return(tR);
        elif tR=NULL then return(tL);
        else
            if intersect(tL,tR)<>{} then
                lprint('intersect not empty:'.string(intersect(tL,tR)).If(length(t)>3,' '.t[4],''));
                tL := minus(tL, tR);
            fi;
            for p1 in tL do for p2 in tR do
                if not __PWR[{p1,p2}]=unassigned then
                    lprint('assertion failure:',p1,p2);
                    assert( __PWR[{p1,p2}] = unassigned );
                fi:
                if length(t)=3 or member(t['xtra'], SPEC) then ev := 'S';
                elif member(t['xtra'],DUPL) then ev:='D';
		elif max( seq(SearchString(z,t['xtra']), z=SPEC_MATCH) )>=0 then ev := 'S';
		elif max( seq(SearchString(z,t['xtra']), z=DUPL_MATCH) )>=0 then ev := 'D';
		else lprint('dubious event: ',t['xtra']); ev := t['xtra']; fi:
                __PWR[{p1,p2}] := ev;
            od od:
            return( union(tL,tR) );
        fi:
    fi:
end:

ExtractPairwiseRel := proc(t:Tree ; (mapping=NULL):table)
    global __PWR; __PWR := table();
    prots := ExtractPairRelR(t, mapping):
    return( [prots, __PWR] );
end:



to 1 do
######################################################################
#   ___  __  __    _      ____    _  _____  _    ____  _____ _____ 
#  / _ \|  \/  |  / \    |  _ \  / \|_   _|/ \  / ___|| ____|_   _|
# | | | | |\/| | / _ \   | | | |/ _ \ | | / _ \ \___ \|  _|   | |  
# | |_| | |  | |/ ___ \  | |_| / ___ \| |/ ___ \ ___) | |___  | |  
#  \___/|_|  |_/_/   \_\ |____/_/   \_\_/_/   \_\____/|_____| |_|  
#
######################################################################

SetDatasetVariables('OMA');
if overwrite=true then
    for f in [outfile, outfile_semiauto] do 
        OpenWriting(f);
        printf('ReconciledTrees := table():\n');
        OpenWriting(previous);
    od:
fi:

##############################################
# PFAM 962 rectree of Engelhardt et al. (2006)
t := ReadRawFile(datdir.'raw/reconciled-PF00962.nex');
label:= 'Eukaryotic Tree of PFam 962';
name := 'PF00962';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Engelhardt BE, Jordan MI, Brenner SE (2006) A graphical model for '
      . 'predicting protein molecular function. In: Cohen WW, Moore A, editors. '
      . 'ICML 2006: Proceedings of the 23th International Conference on Machine '
      . 'Learning. ACM. pp. 297-304.');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# NOX cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/nox.nhx');
mapping := 0; ReadProgram(datdir.'raw/nox.map'); 
assert(mapping<>0);
label:= 'NOX protein familiy';
name := 'NOX';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree, mapping):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the NOX gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# POP cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/pop.nhx');
mapping := 0; ReadProgram(datdir.'raw/pop.map'); 
assert(mapping<>0);
label:= 'POP protein familiy';
name := 'POP';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree, mapping):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the POP gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# VATB cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/vatb.nhx');
mapping := 0; ReadProgram(datdir.'raw/vatb.map'); 
assert(mapping<>0);
label:= 'VATB protein familiy';
name := 'VATB';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree, mapping):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the VATB gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());



##################################################################################
#  ____       __ ____       _   ____    ____    _  _____  _    ____  _____ _____ 
# |  _ \ ___ / _/ ___|  ___| |_| ___|  |  _ \  / \|_   _|/ \  / ___|| ____|_   _|
# | |_) / _ \ |_\___ \ / _ \ __|___ \  | | | |/ _ \ | | / _ \ \___ \|  _|   | |  
# |  _ <  __/  _|___) |  __/ |_ ___) | | |_| / ___ \| |/ ___ \ ___) | |___  | |  
# |_| \_\___|_| |____/ \___|\__|____/  |____/_/   \_\_/_/   \_\____/|_____| |_|  
#                                                                                
##################################################################################
SetDatasetVariables('RefSet5');
if overwrite=true then
    for f in [outfile, outfile_semiauto] do 
        OpenWriting(f);
        printf('ReconciledTrees := table():\n');
        OpenWriting(previous);
    od:
fi:

###########################################
# NOX cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/NOX1-4_referenceProteome.nhx');
label:= 'NOX protein familiy';
name := 'NOX';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the NOX gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# POP cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/POP_referenceProteome.nhx');
label:= 'POP protein familiy';
name := 'POP';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the POP gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# VATB cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/VATB_referenceProteome.nhx');
label:= 'VATB protein familiy';
name := 'VATB';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the VATB gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# SERC cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/SERC_referenceProteome.nhx');
label:= 'SERC protein familiy';
name := 'SERC';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the SERC gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# HOX cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/HOX9-14_referenceProteome.nhx');
label:= 'HOX protein familiy';
name := 'HOX';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the HOX gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

###########################################
# RPS cluster of Brigitte Boeckmann. (2010)
t := ReadRawFile(datdir.'raw/RPS10_referenceProteome.nhx');
label:= 'RPS protein familiy';
name := 'RPS';
tree := ParseNewickTree(t):
map  := ExtractPairwiseRel(tree):
case := RecTreeCase(name, label, map[1], map[2], tree, 
      'Brigitte Boeckmann (2010) Manually reconciled phylogenetic tree of '.
      'the RPS gene family ');
OpenAppending(outfile);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name],UTCTime());

############################################
# All of Treefam A
name := 'TreeFamA';
label:= 'Reconciled gene trees from TreeFam A';
t := ReadRawFile(datdir.'raw/treefam/treefam2reference.txt');
mapping := table():
for z in SplitLines(t) do
    x := SearchDelim('\t',z[1..-2]);
    mapping[x[1]] := x[2];
od:
fams := TimedCallSystem('ls '.datdir.'raw/treefam/*.nhx')[2]:
fams := [seq(z[1..-2], z=SplitLines(fams))]:
rels := table(): memb := {}: 
errT := errM := 0;
for fam in fams do 
    tree := traperror(ParseNewickTree( ReadRawFile(fam) )):
    if tree=lasterror then errT:=errT+1; next fi:

    t := traperror(ExtractPairwiseRel(tree,mapping));
    if t=lasterror then errM := errM+1; next fi:
    memb := union(memb, t[1]);
    for z in Indices(t[2]) do 
        rels[z] := t[2,z];
    od:
od:
case := RecTreeCase( name, label, memb, rels, tree,
    'Ruan et al, Nucleic Acids Res. 2008 (Database issue)'):
OpenAppending(outfile_semiauto);
printf('ReconciledTrees[''%s''] := %A:\n', name, case);
OpenAppending(previous);
AddTestProperty(name,noeval(EvaluateRefPhyloTestProperty),[name,'SemiAuto'],UTCTime());


od:
lprint('lasterror:',lasterror);
done
